#include "ThRMSDCuda.cuh"
#include "kernel_functions_cuda.cuh"
#include <iostream>
using namespace std;

#define floating_point_type float

inline void checkCudaError(char* id, cudaError_t error_code){
	if (error_code != 0){
		cout<<"Error in "<<id<<" . Error code: "<<error_code<<". Exiting..."<<flush<<endl;
		exit(-1);
	}
}

ThRMSDCuda::ThRMSDCuda(int numberOfConformations, int atomsPerConformation, double* coords, int threads_per_block, int number_of_blocks):
				RMSD(numberOfConformations, atomsPerConformation, coords){
    
	float time;
	int total_num_of_coords = this->numberOfConformations*this->atomsPerConformation*3;
    
    // Convert to our floating point type
    this->tmpHostCoords = new floating_point_type[total_num_of_coords];
    for(int i = 0; i < total_num_of_coords; ++i){
    	this->tmpHostCoords[i] = (floating_point_type) coords[i];
    }
    
	// Allocate space for temporary rmsds
	this->tmpHostRMSDs = new floating_point_type[numberOfConformations];
    
	//////////////////////////////////////////////////////////
	//// Set up GPU
	//////////////////////////////////////////////////////////
	this->threadsPerBlock = threads_per_block;
	this->numberOfBlocks = number_of_blocks;
	
	cudaEvent_t start;
	cudaEventCreate(&start);
	cudaEvent_t end;
	cudaEventCreate( &end);
	cudaEvent_t start_centering;
	cudaEventCreate(&start_centering);
	cudaEvent_t end_centering;
	cudaEventCreate( &end_centering);
	
	cudaEventRecord( start, 0 );
	// GPU Data allocation for input
	checkCudaError(" Malloc Device Coords. ", cudaMalloc((void **) &deviceCoords, total_num_of_coords * sizeof(floating_point_type)));
	checkCudaError(" Copying Coords to Device. ", cudaMemcpy(deviceCoords, tmpHostCoords, total_num_of_coords * sizeof(floating_point_type), 
			cudaMemcpyHostToDevice));
    
    // GPU Data allocation for output
    checkCudaError(" Malloc RMSDs ", cudaMalloc((void **) &deviceRMSDs, numberOfConformations * sizeof(floating_point_type)));
    cudaEventRecord( end, 0 );
    cudaEventSynchronize(end);
    
    cudaEventElapsedTime(&time, start, end);	
    cout<<"Time for memory transfer (ms):"<<time<<endl;	 
    cudaEventDestroy(start);
    cudaEventDestroy(end);
    
    
    //////////////////////////////////////////////////////////
	//// And do some pre-processing
	//////////////////////////////////////////////////////////
	cudaEventRecord(start_centering, 0);
    centerCoordsOfAllConformations<<<numberOfBlocks, threadsPerBlock>>>(numberOfConformations,atomsPerConformation,deviceCoords);
    cudaEventRecord(end_centering, 0);
    cudaEventSynchronize(end_centering);
    cudaEventElapsedTime(&time, start_centering, end_centering);	
    cout<<"Time for centering (ms):"<<time<<endl;	 
    cudaEventDestroy(start_centering);
    cudaEventDestroy(end_centering);
}

ThRMSDCuda::~ThRMSDCuda(){
    checkCudaError(" deviceCoords cudaFree ", cudaFree(this->deviceCoords));
    checkCudaError(" deviceRMSDs cudaFree ", cudaFree(this->deviceRMSDs));
    delete [] this->tmpHostRMSDs;
    delete [] this->tmpHostCoords;
}

void ThRMSDCuda::oneVsTheOthers(int conformation, double* rmsd_result) {
	if (conformation < numberOfConformations){
	    calcRMSDOfOneVsOthers<<<numberOfBlocks,threadsPerBlock>>>(this->deviceCoords, conformation, conformation + 1, 
	    			numberOfConformations, atomsPerConformation, this->deviceRMSDs);
	    
	    checkCudaError(" Getting RMSDs from Device. ", cudaMemcpy(this->tmpHostRMSDs, this->deviceRMSDs, 
	    											   numberOfConformations * sizeof(floating_point_type), cudaMemcpyDeviceToHost));
	    
	    // Do the copy to the output vector (need to have the correct size)
		int j = 0;
		for (int i = conformation + 1; i < numberOfConformations;++i,++j){
			rmsd_result[j] = (double) this->tmpHostRMSDs[i];
		}
	}
}

void ThRMSDCuda::calculateRMSDCondensedMatrix(vector<double>& rmsd){ 
	float time;
	cudaEvent_t start;
	cudaEventCreate(&start);
	cudaEvent_t end;
	cudaEventCreate( &end);

	cudaEventRecord(start, 0 );
	for(int conformation_number = 0;conformation_number < numberOfConformations; ++conformation_number){ 
		int number_of_rmsds = numberOfConformations - conformation_number-1;
		double* rmsd_tmp = new double[number_of_rmsds];
    	oneVsTheOthers(conformation_number,rmsd_tmp);
		for (int i = 0; i < number_of_rmsds; ++i){
			rmsd.push_back(rmsd_tmp[i]);
		}
		delete [] rmsd_tmp;
	}
	
	cudaEventRecord(end, 0 );
    cudaEventSynchronize(end);
    
    cudaEventElapsedTime(&time, start, end);	
    cout<<"Time for calculations (ms):"<<time<<endl;	
     
    cudaEventDestroy(start);
    cudaEventDestroy(end);
    
}

void ThRMSDCuda::getDeviceCoordinates(vector<double>& coordinates){
	int number_of_coords = numberOfConformations*atomsPerConformation*3;
    floating_point_type* tmpCoords = new floating_point_type[number_of_coords];
	checkCudaError(" Getting Coordinates from Device. ", 
		cudaMemcpy(tmpCoords, deviceCoords, number_of_coords * sizeof(floating_point_type), cudaMemcpyDeviceToHost)
	);
	coordinates.clear();
	for (int i = 0; i < number_of_coords; ++i){
		coordinates.push_back((double)tmpCoords[i]);
	}
	delete [] tmpCoords;
}